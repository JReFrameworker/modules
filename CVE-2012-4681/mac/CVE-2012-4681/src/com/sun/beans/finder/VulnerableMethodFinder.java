package com.sun.beans.finder;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;

import com.sun.beans.WeakCache;

import jreframeworker.annotations.methods.DefineMethod;
import jreframeworker.annotations.methods.DefineMethodVisibility;
import jreframeworker.annotations.types.DefineTypeFinality;
import jreframeworker.annotations.types.MergeType;

@DefineTypeFinality(type = "com.sun.beans.finder.MethodFinder", finality = false)
@DefineMethodVisibility(type = "com.sun.beans.finder.MethodFinder", method = "MethodFinder", visibility = "public")
@MergeType
public class VulnerableMethodFinder extends com.sun.beans.finder.MethodFinder {

	public VulnerableMethodFinder(String name, Class<?>[] args) {
		super(name, args);
	}

	// place holder for field to compile against
	private static final WeakCache<Signature, Method> CACHE = new WeakCache();

	@DefineMethod
	public static Method findMethod(Class<?> paramClass, String paramString, Class<?>[] paramArrayOfClass) throws NoSuchMethodException {
		if (paramString == null) {
			throw new IllegalArgumentException("Method name is not set");
		}
		PrimitiveWrapperMap.replacePrimitivesWithWrappers(paramArrayOfClass);
		Signature localSignature = new Signature(paramClass, paramString, paramArrayOfClass);

		Method localMethod = (Method) CACHE.get(localSignature);
		int i = localMethod != null ? 1 : 0;
//		if ((i != 0) && (ReflectUtil.isPackageAccessible(localMethod.getDeclaringClass()))) {
//			return localMethod;
//		}
		// removed security checks
		if (i != 0) {
			return localMethod;
		}
		localMethod = findAccessibleMethod((Method) new MethodFinder(paramString, paramArrayOfClass).find(paramClass.getMethods()));
		if (i == 0) {
			CACHE.put(localSignature, localMethod);
		}
		return localMethod;
	}

	@DefineMethod
	public static Method findAccessibleMethod(Method paramMethod) throws NoSuchMethodException {
		Class localClass = paramMethod.getDeclaringClass();
//		if ((Modifier.isPublic(localClass.getModifiers())) && (ReflectUtil.isPackageAccessible(localClass))) {
//			return paramMethod;
//		}
		// removed security checks
		if ((Modifier.isPublic(localClass.getModifiers()))) {
			return paramMethod;
		}
		if (Modifier.isStatic(paramMethod.getModifiers())) {
			throw new NoSuchMethodException("Method '" + paramMethod.getName() + "' is not accessible");
		}
		for (Type localType : localClass.getGenericInterfaces()) {
			try {
				return findAccessibleMethod(paramMethod, localType);
			} catch (NoSuchMethodException localNoSuchMethodException) {
			}
		}
		return findAccessibleMethod(paramMethod, localClass.getGenericSuperclass());
	}
	
	// place holder for the real thing
	private static Method findAccessibleMethod(Method paramMethod, Type paramType) throws NoSuchMethodException {
		return null;
	}

}
